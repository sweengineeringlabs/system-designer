use axum::routing::{get, post};
use axum::{Json, Router};
use serde::{Deserialize, Serialize};

pub mod middleware;

pub fn app() -> Router {
    Router::new()
        .route("/health", get(|| async { "OK" }))
        .route("/generate", post(generate_design))
        .layer(middleware::cors())
}

#[derive(Deserialize, Serialize, Debug)]
pub struct DesignRequest {
    pub purpose: Purpose,
    pub prompt: Prompt,
    pub model: ModelConfig,
    pub tools: Tools,
    pub memory: Memory,
    pub orchestration: Orchestration,
    pub interface: Interface,
    pub testing: Testing,
}

#[derive(Deserialize, Serialize, Debug)]
pub struct Purpose {
    pub use_case: String,
    pub user_needs: String,
    pub success_criteria: String,
    pub constraints: String,
}

#[derive(Deserialize, Serialize, Debug)]
pub struct Prompt {
    pub goals: String,
    pub role: String,
    pub instructions: String,
    pub guardrails: String,
}

#[derive(Deserialize, Serialize, Debug)]
pub struct ModelConfig {
    pub base_model: String,
    pub parameters: String,
    pub context_window: String,
    pub cost_latency_tradeoff: String,
}

#[derive(Deserialize, Serialize, Debug)]
pub struct Tools {
    pub apis: Vec<String>,
    pub mcp_servers: Vec<String>,
    pub custom_functions: String,
}

#[derive(Deserialize, Serialize, Debug)]
pub struct Memory {
    pub episodic: bool,
    pub working_memory: bool,
    pub vector_db: String,
    pub sql_db: String,
}

#[derive(Deserialize, Serialize, Debug)]
pub struct Orchestration {
    pub workflow: String,
    pub triggers: String,
    pub error_handling: String,
}

#[derive(Deserialize, Serialize, Debug)]
pub struct Interface {
    pub platform: String,
    pub interaction_mode: String,
    pub api_endpoint: String,
}

#[derive(Deserialize, Serialize, Debug)]
pub struct Testing {
    pub unit_tests: Vec<String>,
    pub quality_metrics: String,
    pub evals: String,
}

#[derive(Serialize)]
struct DesignResponse {
    markdown: String,
}

// Pure logic function - decoupled from Axum
pub fn core_generate_design(payload: &DesignRequest) -> String {
    format!(r#"# System Design Specification: {}

## 1. Purpose & Scope
- **Use Case:** {}
- **User Needs:** {}
- **Success Criteria:** {}
- **Constraints:** {}

## 2. System Prompt Design
- **Role & Persona:** {}
- **Primary Goals:** {}
- **Instructions:** {}
- **Guardrails:** {}

## 3. Model Selection
- **Base Model:** {}
- **Parameters:** {}
- **Context Window:** {}
- **Tradeoffs:** {}

## 4. Tools & Integrations
- **External APIs:** {:?}
- **MCP Servers:** {:?}
- **Custom Functions:** {}

## 5. Memory Systems
- **Episodic Memory:** {}
- **Working Memory:** {}
- **Vector Database:** {}
- **SQL/Structured DB:** {}

## 6. Orchestration
- **Workflow Pattern:** {}
- **System Triggers:** {}
- **Error Handling:** {}

## 7. User Interface
- **Platform:** {}
- **Interaction Mode:** {}
- **API Strategy:** {}

## 8. Testing & Evals
- **Unit Tests:** {:?}
- **Quality Metrics:** {}
- **Evaluation Strategy:** {}

---
*Generated by System Designer Agent on 2025-12-21*"#,
        payload.purpose.use_case,
        payload.purpose.use_case,
        payload.purpose.user_needs,
        payload.purpose.success_criteria,
        payload.purpose.constraints,
        payload.prompt.role,
        payload.prompt.goals,
        payload.prompt.instructions,
        payload.prompt.guardrails,
        payload.model.base_model,
        payload.model.parameters,
        payload.model.context_window,
        payload.model.cost_latency_tradeoff,
        payload.tools.apis,
        payload.tools.mcp_servers,
        payload.tools.custom_functions,
        payload.memory.episodic,
        payload.memory.working_memory,
        payload.memory.vector_db,
        payload.memory.sql_db,
        payload.orchestration.workflow,
        payload.orchestration.triggers,
        payload.orchestration.error_handling,
        payload.interface.platform,
        payload.interface.interaction_mode,
        payload.interface.api_endpoint,
        payload.testing.unit_tests,
        payload.testing.quality_metrics,
        payload.testing.evals
    )
}

// Handler calls the pure function
async fn generate_design(Json(payload): Json<DesignRequest>) -> Json<DesignResponse> {
    let md = core_generate_design(&payload);
    Json(DesignResponse { markdown: md })
}